namespace Analyzer {
    !structure LiteralToken {
        flags :: enumerare !Flag :: UInt8 {
            Cooked = 1,
            Bit8 = 2,
            Bit16 = 4,
            Bit32 = 8,
            Bit64 = 16,
            Bit128 = 32,
        },
        kind :: enumerare !Kind :: UInt8 {
            Integer,
            Float,
            Character,
            String,
        },
        value :: unistruct !Value {
            Integer :: UInt64,
            Float :: Float128,
            Character :: Int8,
            String :: @Int8,
        },
    }

    !structure Token {
        start :: structure Point {
            row :: UInt64,
            column :: UInt64,
        },
        end :: Token::Point;
        kind :: enumerare !Kind :: UInt8 {
            None,
            Identifier,
            Keyword,
            Literal,
            Punctuator,
            Operator,
            Modifier,
        },
        value :: unistruct !Value {
            Identifier :: @Int8,
            Keyword :: UInt8,
            Literal :: LiteralToken,
            Punctuator :: Int16,
            Operator :: Int16,
            Modifier :: Int16,
        },
    }

    implement Token {
        procedure !Create(
            kind :: Token:Kind,
            value :: Token:Value,
            start :: Token:Point = Token:Point {
                .row = 0,
                .column = 0,
            },
            end :: Token:Point = Token:Point {
                .row = 0,
                .column = 0,
            },
        ) -> Token {
            return Token {
                .kind = kind,
                .value = value,
                .start = start,
                .end = end,
            };
        }

        @?procedure !Destroy {
            if .kind == Token:Kind:Identifier
                => jumpto IDENTIFIER;
            if .kind == Token:Kind:Literal
                => jumpto LITERAL;
        label IDENTIFIER :=
            Memory:Free(.value.Identifier);
        label LITERAL :=
            if .value.Literal.kind != LiteralToken:Kind:String
                => jumpto END;
            Memory:Free(.value.Literal.value.String);
        label END :=
        }

        @procedure !Kind -> @Token:Kind !
            => return @.kind;

        @?procedure !Kind(kind :: Token:Kind) !
            => .kind = kind;

        @procedure !Value -> @Token:Value !
            => return @.value;

        @?procedure !Value(value :: Token:Value) !
            => .value = value;
    }

    implement Token:Kind {
        @procedure !ToStr -> @Int8 !{
            if . == Token:Kind:None => return "None";
            if . == Token:Kind:Identifier => return "Identifier";
            if . == Token:Kind:Keyword => return "Keyword";
            if . == Token:Kind:Literal => return "Literal";
            if . == Token:Kind:Punctuator => return "Punctuator";
            if . == Token:Kind:Operator => return "Operator";
            if . == Token:Kind:Modifier => return "Modifier";
        }
    }
}

namespace Analyzer {
    structure Lexer
}
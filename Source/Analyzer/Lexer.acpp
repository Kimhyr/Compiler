#include "Lexer.h"

namespace Klang {

Lexer::Lexer(const char* path)
	: _source(path), _index(0), _position(1, 1) {
	if (!this->_source.is_open())
		throw std::invalid_argument("The source file failed to open.");
	this->_current = this->_source.get();
}

void Lexer::load(const char* path) {
	this->_source.close();
	this->_source.open(path);
	if (!this->_source.is_open())
		throw std::invalid_argument("");
	this->_current = this->_source.get();
	this->_position.row = 1;
	this->_position.column = 0;
	this->_index = 0;
}

void Lexer::lex(Token& token) {
	while (std::isspace(this->current()))
		this->advance();
	token.start = this->position();
	switch (static_cast<TokenKind>(this->current())) {
	case Token::SLOSH:
		do this->advance();
		while (this->current() != '\n');
		token.kind = Token::COMMENT;
		break;
	case Token::PLUS:
	case Token::MINUS:
	case Token::EOT:
	case Token::COLON:
	case Token::SEMICOLON:
	case Token::EQUAL:
	case Token::ASTERISKS:
	case Token::SLASH:
	case Token::PERCENT:
	case Token::OPAREN:
	case Token::CPAREN:
		token.kind = static_cast<TokenKind>(this->current());
		this->advance();
		break;
	default:
		if (std::isalpha(this->current())) {
			Bucket<char, Token::MAX_VALUE_LENGTH + 1> bucket;
			do {
				if (bucket.weight() >= Token::MAX_VALUE_LENGTH)
					throw std::overflow_error("The bucket overflowed when trying to lex a token.");
				bucket.put(this->current());
				this->advance();
			} while (this->current() == '_' || std::isdigit(this->current()) ||
				 std::isalpha(this->current()));
			bucket.put('\0');
			if (std::string("object") == bucket.water())
				token.kind = Token::OBJECT;
			else if (std::string("Int") == bucket.water())
				token.kind = Token::INT;
			else {
				token.value = bucket.flush();
				token.kind = Token::NAME;
			}
		} else if (std::isdigit(this->current())) {
			Bucket<char, Token::MAX_VALUE_LENGTH + 1> bucket;
			do {
				if (bucket.weight() >= Token::MAX_VALUE_LENGTH)
					throw std::overflow_error("The bucket overflowed when trying to lex a token.");
				if (this->current() != '_')
					bucket.put(this->current());
				this->advance();
			} while (this->current() == '_' || std::isdigit(this->current()));
			bucket.put('\0');
			token.value = bucket.flush();
			token.kind = Token::NUMBER;
		} else {
			token.kind = Token::UNDEFINED;
			this->advance();
		}
	}
	token.end = this->position();
	--token.end.column;
}

char Lexer::peek() {
	int peek = this->_source.peek();
	if (peek == EOF)
		throw std::out_of_range(__FUNCTION__);
	return peek;
}

void Lexer::advance() {
	if (!this->source().good())
		throw std::invalid_argument("The source file is not \"good\".");
	this->_current = this->_source.get();
	if (this->current() == '\n') {
		++this->_position.row;
		this->_position.column = 0;
	}
	++this->_position.column;
	++this->_index;
}

}
